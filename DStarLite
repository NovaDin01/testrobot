using UnityEngine;
using System;
using System.Collections.Generic;

public class DStarLiteTest : MonoBehaviour
{
    public Transform target; // Цель (выход из лабиринта)
    public LayerMask obstacleMask; // Слои препятствий
    public float nodeRadius = 1f; // Радиус узла графа
    public float movementSpeed = 5f; // Скорость перемещения

    private List<Node> graph = new List<Node>(); // Граф лабиринта
    private Node startNode; // Стартовый узел
    private Node goalNode; // Целевой узел
    private Node currentNode; // Текущий узел
    private List<Node> path = new List<Node>(); // Путь к выходу
    private int currentPathIndex = 0; // Текущий индекс узла в пути

    private SortedSet<Node> openSet; // Приоритетная очередь

    void Start()
    {
        // Создаем граф лабиринта
        CreateGraph();

        // Находим стартовый и целевой узлы
        startNode = GetNearestNode(transform.position);
        goalNode = GetNearestNode(target.position);

        // Инициализируем D* Lite
        currentNode = startNode;
        openSet = new SortedSet<Node>(new NodeComparer());

        path = DStarLite();

        // Если путь к цели найден, начинаем перемещаться
        if (path != null && path.Count > 0)
            MoveToNextNode();
    }

    void Update()
    {
        // Если достигли узла, переходим к следующему
        if (path != null && currentPathIndex < path.Count)
        {
            if (Vector3.Distance(transform.position, path[currentPathIndex].worldPosition) < 0.1f)
            {
                currentPathIndex++;
                MoveToNextNode();
            }
        }
    }

    void MoveToNextNode()
    {
        if (currentPathIndex < path.Count)
        {
            Vector3 targetPosition = path[currentPathIndex].worldPosition;
            targetPosition.y = transform.position.y; // Сохраняем высоту

            transform.position = Vector3.MoveTowards(transform.position, targetPosition, movementSpeed * Time.deltaTime);
        }
    }

    void CreateGraph()
    {
        // Получаем границы лабиринта
        Bounds bounds = new Bounds(transform.position, Vector3.one * 100f);

        // Создаем граф лабиринта на основе препятствий
        for (float x = bounds.min.x; x < bounds.max.x; x += nodeRadius * 2)
        {
            for (float z = bounds.min.z; z < bounds.max.z; z += nodeRadius * 2)
            {
                Vector3 point = new Vector3(x, 0f, z);
                bool isObstacle = Physics.CheckSphere(point, nodeRadius, obstacleMask);
                if (!isObstacle)
                {
                    Node node = new Node(point);
                    graph.Add(node);
                }
            }
        }

        // Связываем узлы
        foreach (Node node in graph)
        {
            List<Node> neighbors = new List<Node>();
            foreach (Node otherNode in graph)
            {
                if (node != otherNode && Vector3.Distance(node.worldPosition, otherNode.worldPosition) <= nodeRadius * 2.1f)
                {
                    neighbors.Add(otherNode);
                }
            }
            node.neighbors = neighbors;
        }
    }

    List<Node> DStarLite()
    {
        // Инициализация
        foreach (Node node in graph)
        {
            node.rhs = Mathf.Infinity;
            node.g = Mathf.Infinity;
            node.key = new NodeKey(Mathf.Infinity, Mathf.Infinity);
        }

        goalNode.rhs = 0;
        goalNode.key = CalculateKey(goalNode);

        openSet.Clear();
        openSet.Add(goalNode);

        while (openSet.Count > 0 && (openSet.Min.key.CompareTo(CalculateKey(startNode)) < 0 || startNode.rhs != startNode.g))
        {
            Node current = openSet.Min;
            openSet.Remove(current);

            if (current.g > current.rhs)
            {
                current.g = current.rhs;
                foreach (Node neighbor in current.neighbors)
                {
                    UpdateVertex(neighbor);
                }
            }
            else
            {
                current.g = Mathf.Infinity;
                UpdateVertex(current);
                foreach (Node neighbor in current.neighbors)
                {
                    UpdateVertex(neighbor);
                }
            }
        }

        // Строим путь
        List<Node> path = new List<Node>();
        Node currentPathNode = startNode;

        while (currentPathNode != goalNode)
        {
            path.Add(currentPathNode);

            float minCost = Mathf.Infinity;
            Node nextNode = null;

            foreach (Node neighbor in currentPathNode.neighbors)
            {
                if (neighbor.g + Vector3.Distance(currentPathNode.worldPosition, neighbor.worldPosition) < minCost)
                {
                    minCost = neighbor.g + Vector3.Distance(currentPathNode.worldPosition, neighbor.worldPosition);
                    nextNode = neighbor;
                }
            }

            currentPathNode = nextNode;
        }

        path.Add(goalNode);

        return path;
    }

    void UpdateVertex(Node node)
    {
        if (node != goalNode)
        {
            node.rhs = Mathf.Infinity;
            foreach (Node neighbor in node.neighbors)
            {
                node.rhs = Mathf.Min(node.rhs, neighbor.g + Vector3.Distance(node.worldPosition, neighbor.worldPosition));
            }
        }

        if (openSet.Contains(node))
        {
            openSet.Remove(node);
        }

        if (node.g != node.rhs)
        {
            node.key = CalculateKey(node);
            openSet.Add(node);
        }
    }

    NodeKey CalculateKey(Node node)
    {
        float k1 = Mathf.Min(node.g, node.rhs);
        float k2 = Mathf.Min(node.g, node.rhs);

        return new NodeKey(k1 + Heuristic(node, startNode), k2);
    }

    float Heuristic(Node a, Node b)
    {
        return Vector3.Distance(a.worldPosition, b.worldPosition);
    }

    Node GetNearestNode(Vector3 position)
    {
        Node nearestNode = null;
        float shortestDistance = Mathf.Infinity;

        foreach (Node node in graph)
        {
            float distance = Vector3.Distance(position, node.worldPosition);
            if (distance < shortestDistance)
            {
                shortestDistance = distance;
                nearestNode = node;
            }
        }

        return nearestNode;
    }

    // Представление узла
    public class Node
    {
        public Vector3 worldPosition;
        public List<Node> neighbors;
        public float g; // Расстояние от старта до текущего узла
        public float rhs; // Следующее лучшее расстояние от старта до текущего узла
        public NodeKey key; // Ключ для определения приоритета в очереди

        public Node(Vector3 position)
        {
            worldPosition = position;
            neighbors = new List<Node>();
        }
    }

    // Класс ключа для узла
    public class NodeKey : IComparable<NodeKey>
    {
        public float k1;
        public float k2;

        public NodeKey(float k1, float k2)
        {
            this.k1 = k1;
            this.k2 = k2;
        }

        public int CompareTo(NodeKey other)
        {
            if (k1 < other.k1 || (k1 == other.k1 && k2 < other.k2))
                return -1;
            else if (k1 == other.k1 && k2 == other.k2)
                return 0;
            else
                return 1;
        }
    }

    // Сравнитель для сортировки узлов по ключу
    public class NodeComparer : IComparer<Node>
    {
        public int Compare(Node x, Node y)
        {
            return x.key.CompareTo(y.key);
        }
    }
}
